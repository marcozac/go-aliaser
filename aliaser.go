package aliaser

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"go/types"
	"io"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"sync"
	"text/template"

	"github.com/marcozac/go-aliaser/importer"
	"github.com/marcozac/go-aliaser/util/maps"
	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

//go:embed template/*
var tmplFS embed.FS

// Aliaser is the primary type of this package. It is used to generate the
// aliases for the loaded package.
type Aliaser struct {
	*Config
	*importer.Importer

	// constants is the list of exported constants in the loaded package.
	constants []*Const

	// Variables is the list of exported variables in the loaded package.
	variables []*Var

	// Functions is the list of exported functions in the loaded package.
	functions []*Func

	// Types is the list of exported types in the loaded package.
	types []*TypeName

	names *maps.Safe[string, objectId]
	mu    sync.RWMutex
}

// New returns a new [Aliaser] with the given configuration. The configuration
// must include at least the target package, which is the name of the package
// where the aliases will be generated.
//
// By default, New does not load any package and returns an empty [Aliaser],
// leaving to the user to call the [Aliaser.Load] method, but, since
// [LoadOption] implements also the [Option] interface, it is possible to pass
// them directly to New. In this case, if at least one pattern is set, New will
// load thepackages with the given patterns and options before returning the
// [Aliaser] and an error if the loading fails.
//
// Example:
//
//	a, err := aliaser.New(
//		aliaser.Config{TargetPackage: "foo"},
//		aliaser.WithPatterns("github.com/example/package/foo"),
//	)
//	if err != nil {
//		// ...
//	}
//	err = a.GenerateFile("foo/alias.go")
//
//	// foo/alias.go:
//	// Code generated by aliaser. DO NOT EDIT.
//
//	package foo
//
//	 import (
//		"github.com/example/package/foo"
//	 )
//
//	 const (
//		A = foo.A
//		B = foo.B
//	 )
//
//	 type (
//		T1 = foo.T1
//		T2 = foo.T2
//	 )
func New(c Config, opts ...Option) (*Aliaser, error) {
	if c.TargetPackage == "" {
		return nil, ErrEmptyTarget
	}
	a := &Aliaser{
		Config:   c.setDefaults().applyOptions(opts...),
		Importer: importer.New(),
		names:    maps.NewSafe(make(map[string]objectId)),
	}
	if err := a.load(&a.firstLoad); err != nil {
		return nil, err
	}
	return a, nil
}

// Load loads the packages that match the given patterns and, for each package,
// adds the constants, variables, functions, and types to the aliaser,
// respecting [Config.OnDuplicate] setting.
//
// Any field of the given [LoadConfig], which can be nil, can be set using the
// [LoadOption] functions. If the configuration does not contain any pattern
// and they are not set using the [WithPatterns] function, Load is a no-op.
//
// Load tries to load the packages in the order they are specified in the
// patterns. The patterns are compared with the package path as a prefix
// (without traling "/...", if present), but the order is not guaranteed.
func (a *Aliaser) Load(c *LoadConfig, opts ...LoadOption) error {
	a.mu.Lock()
	defer a.mu.Unlock()
	return a.load(c.applyOptions(opts...))
}

const loadMode = packages.NeedName | packages.NeedTypes

func (a *Aliaser) load(c *LoadConfig) error {
	if len(c.Patterns) == 0 {
		return nil
	}
	pkgs, err := packages.Load(&packages.Config{Mode: loadMode, Context: c.Context}, c.Patterns...)
	if err != nil {
		return fmt.Errorf("packages.Load: %w", err)
	}
	tpkgs := make([]*types.Package, len(pkgs))
	for i, pkg := range pkgs {
		if len(pkg.Errors) > 0 {
			return fmt.Errorf("%s: %w", pkg.PkgPath, PackagesErrors(pkg.Errors))
		}
		tpkgs[i] = pkg.Types
	}
	slices.SortFunc(tpkgs, func(a, b *types.Package) int {
		ai := slices.IndexFunc(c.Patterns, newPatternIndexer(a))
		bi := slices.IndexFunc(c.Patterns, newPatternIndexer(b))
		return ai - bi
	})
	return a.addPackages(c, tpkgs...)
}

func newPatternIndexer(pkg *types.Package) func(pattern string) bool {
	return func(pattern string) bool {
		return strings.HasPrefix(pkg.Path(), strings.TrimSuffix(pattern, "/..."))
	}
}

func (a *Aliaser) addPackages(c *LoadConfig, pkgs ...*types.Package) error {
	for _, pkg := range pkgs {
		if err := a.addPackageObjects(c, pkg); err != nil {
			return err
		}
	}
	return nil
}

func (a *Aliaser) addPackageObjects(c *LoadConfig, pkg *types.Package) error {
	a.AddImport(pkg)
	scope := pkg.Scope()
	for _, name := range pkg.Scope().Names() {
		o := scope.Lookup(name)
		if !o.Exported() {
			continue
		}
		if slices.Contains(c.ExcludeNames, o.Name()) {
			continue
		}
		switch o := o.(type) {
		case *types.Const:
			if !c.ExcludeConstants {
				a.addConstant(o)
			}
		case *types.Var:
			if !c.ExcludeVariables {
				a.addVariable(o)
			}
		case *types.Func:
			if !c.ExcludeFunctions {
				a.addFunction(o)
			}
		case *types.TypeName:
			if !c.ExcludeTypes {
				a.addType(o)
			}
		default: // should never happen
			return fmt.Errorf("unexpected object type for %s: %T", o.Name(), o)
		}
	}
	return nil
}

// Constants returns the list of the constants loaded for aliasing.
func (a *Aliaser) Constants() []*Const {
	a.mu.RLock()
	defer a.mu.RUnlock()
	return a.constants
}

// AddConstants adds the given constants to the list of the constants to
// generate aliases for.
func (a *Aliaser) AddConstants(cs ...*types.Const) {
	a.mu.Lock()
	defer a.mu.Unlock()
	for _, c := range cs {
		a.addConstant(c)
	}
}

func (a *Aliaser) addConstant(c *types.Const) {
	if !a.addObjectName(c, constantId) {
		a.constants = append(a.constants, NewConst(c, a.Importer))
		a.AddImport(c.Pkg())
	}
}

// Variables returns the list of the variables loaded for aliasing.
func (a *Aliaser) Variables() []*Var {
	a.mu.RLock()
	defer a.mu.RUnlock()
	return a.variables
}

// AddVariables adds the given variables to the list of the variables to
// generate aliases for.
func (a *Aliaser) AddVariables(vs ...*types.Var) {
	a.mu.Lock()
	defer a.mu.Unlock()
	for _, v := range vs {
		a.addVariable(v)
	}
}

func (a *Aliaser) addVariable(v *types.Var) {
	if !a.addObjectName(v, variableId) {
		a.AddImport(v.Pkg())
		a.variables = append(a.variables, NewVar(v, a.Importer))
	}
}

// Functions returns the list of the functions loaded for aliasing.
func (a *Aliaser) Functions() []*Func {
	a.mu.RLock()
	defer a.mu.RUnlock()
	return a.functions
}

// AddFunctions adds the given functions to the list of the functions to
// generate aliases for.
func (a *Aliaser) AddFunctions(fns ...*types.Func) {
	a.mu.Lock()
	defer a.mu.Unlock()
	for _, fn := range fns {
		a.addFunction(fn)
	}
}

func (a *Aliaser) addFunction(fn *types.Func) {
	if !a.addObjectName(fn, functionId) {
		a.AddImport(fn.Pkg())
		a.functions = append(a.functions, NewFunc(fn, a.Importer))
	}
}

// Types returns the list of the types loaded for aliasing.
func (a *Aliaser) Types() []*TypeName {
	a.mu.RLock()
	defer a.mu.RUnlock()
	return a.types
}

// AddTypes adds the given types to the list of the types to generate aliases
// for.
func (a *Aliaser) AddTypes(ts ...*types.TypeName) {
	a.mu.Lock()
	defer a.mu.Unlock()
	for _, t := range ts {
		a.addType(t)
	}
}

func (a *Aliaser) addType(t *types.TypeName) {
	if !a.addObjectName(t, typeId) {
		a.AddImport(t.Pkg())
		a.types = append(a.types, NewTypeName(t, a.Importer))
	}
}

// objectId is the type used to identify the kind of object.
type objectId int

const (
	_ objectId = iota
	constantId
	variableId
	functionId
	typeId
)

func (a *Aliaser) addObjectName(o types.Object, id objectId) (skip bool) {
	if a.names.PutNX(o.Name(), id) {
		return
	}
	switch a.OnDuplicate {
	case OnDuplicateSkip:
		return true
	case OnDuplicateReplace:
		oldID, ok := a.names.Swap(o.Name(), id)
		if ok {
			a.deleteObject(o, oldID)
		}
	case OnDuplicatePanic:
		panic(fmt.Errorf("duplicate object name: %s", o.Name()))
	default: // should never happen, trap for development
		panic(fmt.Errorf("unexpected OnDuplicate value: %d", a.OnDuplicate))
	}
	return
}

func (a *Aliaser) deleteObject(o types.Object, id objectId) {
	switch id {
	case constantId:
		a.constants = slices.DeleteFunc(a.constants, newObjSliceDel[*Const](o))
	case variableId:
		a.variables = slices.DeleteFunc(a.variables, newObjSliceDel[*Var](o))
	case functionId:
		a.functions = slices.DeleteFunc(a.functions, newObjSliceDel[*Func](o))
	case typeId:
		a.types = slices.DeleteFunc(a.types, newObjSliceDel[*TypeName](o))
	default: // should never happen, trap for development
		panic(fmt.Errorf("unexpected object ID: %d", id))
	}
}

// newObjSliceDel returns a function, compatible with the signature of the
// [slices.DeleteFunc], that returns true if the given object (the one that
// will be deleted) has the same name of the one used to create the function.
func newObjSliceDel[O types.Object](obj types.Object) func(O) bool {
	return func(o O) bool {
		return obj.Name() == o.Name()
	}
}

// Generate writes the aliases to the given writer.
//
// Generate returns an error if fails to execute the template, format the
// generated code, or write the result to the writer.
func (a *Aliaser) Generate(wr io.Writer) error {
	a.mu.RLock()
	defer a.mu.RUnlock()
	return a.generate(wr)
}

// GenerateFile behaves like [Aliaser.Generate], but it writes the aliases to
// the file with the given name creating the necessary directories. If the file
// already exists, it is truncated.
//
// GenerateFile returns an error in the same cases as [Aliaser.Generate] and
// if any of the directory creation or file writing operations fail. In this
// case, if the file did not exist before the operation, it is removed,
// otherwise, its content is reset to the original state.
func (a *Aliaser) GenerateFile(name string) error {
	a.mu.RLock()
	defer a.mu.RUnlock()
	if err := os.MkdirAll(filepath.Dir(name), 0o755); err != nil {
		return fmt.Errorf("create directory: %w", err)
	}
	f, reset, err := OpenFileWithReset(name)
	if err != nil {
		return err
	}
	defer f.Close()
	if err := a.generate(f); err != nil {
		err = fmt.Errorf("generate: %w", err)
		if rerr := reset(); rerr != nil {
			return errors.Join(err, fmt.Errorf("reset file: %w", rerr))
		}
		return err
	}
	return nil
}

func (a *Aliaser) generate(wr io.Writer) error {
	buf := new(bytes.Buffer)
	if err := a.executeTemplate(buf); err != nil {
		return err
	}
	data, err := imports.Process("", buf.Bytes(), nil)
	if err != nil {
		return fmt.Errorf("format: %w", err)
	}
	if _, err := wr.Write(data); err != nil {
		return fmt.Errorf("write: %w", err)
	}
	return nil
}

func (a *Aliaser) executeTemplate(buf *bytes.Buffer) error {
	tmpl, err := template.ParseFS(tmplFS, "template/*.tmpl")
	if err != nil {
		return fmt.Errorf("parse: %w", err)
	}
	if err := tmpl.ExecuteTemplate(buf, "alias", a); err != nil {
		return fmt.Errorf("execute: %w", err)
	}
	return nil
}

// Config is the configuration used to define the target package.
type Config struct {
	// [REQUIRED]
	// TargetPackage is the name of the package where the aliases will be
	// generated. For example, if the package path is
	// "github.com/marcozac/go-aliaser/pkg-that-needs-aliases/foo", the target
	// package is "foo".
	TargetPackage string

	// Header is an optional header to be written at the top of the file.
	//
	// Default: "// Code generated by aliaser. DO NOT EDIT."
	Header string

	// AssignFunctions sets whether the aliases for the functions should be
	// assigned to a variable instead of being wrapped.
	//
	// Default: false
	AssignFunctions bool

	// OnDuplicate sets the behavior when a duplicate object name is found.
	// It may be one of the following:
	//   - [OnDuplicateSkip]: skips the object
	//   - [OnDuplicateReplace]: replaces the old object with the new one.
	//     It may be a different kind of object.
	//   - [OnDuplicatePanic]: panics
	//
	// Default: [OnDuplicateSkip]
	OnDuplicate int

	// firstLoad holds initial loading configurations used during the
	// instantiation of [Aliaser] with [New]. This allows for immediate loading
	// of packages based on specified patterns and loading options.
	firstLoad LoadConfig
}

func (c *Config) setDefaults() *Config {
	if c.Header == "" {
		c.Header = "// Code generated by aliaser. DO NOT EDIT."
	}
	return c
}

func (c *Config) applyOptions(opts ...Option) *Config {
	for _, o := range opts {
		o.set(c)
	}
	return c
}

// Option is the interface implemented by all options.
type Option interface{ set(*Config) }

type option func(*Config)

func (o option) set(c *Config) {
	o(c)
}

// WithHeader sets an optional header to be written at the top of the file.
func WithHeader(header string) Option {
	return option(func(c *Config) {
		c.Header = header
	})
}

// AssignFunctions sets whether the aliases for the functions should be
// assigned to a variable instead of being wrapped.
func AssignFunctions(v bool) Option {
	return option(func(c *Config) {
		c.AssignFunctions = v
	})
}

const (
	// OnDuplicateSkip is the default behavior when a duplicate object name is
	// found. It skips the object and does not generate an alias for it.
	OnDuplicateSkip = iota

	// OnDuplicateReplace replaces the old object (even if it is a different
	// kind of object) with the new one.
	OnDuplicateReplace

	// OnDuplicatePanic panics when a duplicate object name is found.
	OnDuplicatePanic
)

// OnDuplicate sets the behavior when a duplicate object name is found.
func OnDuplicate(v int) Option {
	return option(func(c *Config) {
		c.OnDuplicate = v
	})
}

// LoadConfig specifies package(s)-specific loading options, allowing for
// granular control over how each package's objects are handled during
// the alias generation process. Use [LoadOptions] to adjust these settings
// when calling [Aliaser.Load]. For global settings that affect the entire
// aliasing process, refer to [Config].
type LoadConfig struct {
	// Context is the context to be used when loading the packages.
	Context context.Context

	// Patterns is a list of patterns to be used when loading the packages.
	Patterns []string

	// ExcludeConstants indicates whether to exclude the constants from the
	// loaded packages.
	ExcludeConstants bool

	// ExcludeVariables indicates whether to exclude the variables from the
	// loaded packages.
	ExcludeVariables bool

	// ExcludeFunctions indicates whether to exclude the functions from the
	// loaded packages.
	ExcludeFunctions bool

	// ExcludeTypes indicates whether to exclude the types from the loaded
	// packages.
	ExcludeTypes bool

	// ExcludeNames is a list of object names to be excluded from the
	// loaded packages. Each name is valid for all kinds of objects
	// (constants, variables, functions, and types).
	//
	// Example:
	//
	//	c := &LoadConfig{
	//		// If a loaded package has a constant named "A" and a
	//		// type named "B", they will be both excluded.
	//		ExcludeNames = []string{"A", "B"},
	//		// ...
	//	}
	ExcludeNames []string
}

func (lc *LoadConfig) applyOptions(opts ...LoadOption) *LoadConfig {
	if lc == nil {
		lc = new(LoadConfig)
	}
	for _, o := range opts {
		o.setLoad(lc)
	}
	return lc
}

type LoadOption interface {
	Option
	setLoad(*LoadConfig)
}

type loadOption func(*LoadConfig)

func (o loadOption) set(c *Config) {
	o(&c.firstLoad)
}

func (o loadOption) setLoad(lc *LoadConfig) {
	o(lc)
}

// WithContext sets the context to be used when loading the packages.
func WithContext(ctx context.Context) LoadOption {
	return loadOption(func(c *LoadConfig) {
		c.Context = ctx
	})
}

// WithPatterns sets the patterns to be used when loading the packages.
func WithPatterns(patterns ...string) LoadOption {
	return loadOption(func(c *LoadConfig) {
		c.Patterns = patterns
	})
}

// ExcludeConstants excludes the constants from the loaded packages.
func ExcludeConstants(v bool) LoadOption {
	return loadOption(func(c *LoadConfig) {
		c.ExcludeConstants = v
	})
}

// ExcludeVariables excludes the variables from the loaded packages.
func ExcludeVariables(v bool) LoadOption {
	return loadOption(func(c *LoadConfig) {
		c.ExcludeVariables = v
	})
}

// ExcludeFunctions excludes the functions from the loaded packages.
func ExcludeFunctions(v bool) LoadOption {
	return loadOption(func(c *LoadConfig) {
		c.ExcludeFunctions = v
	})
}

// ExcludeTypes excludes the types from the loaded packages.
func ExcludeTypes(v bool) LoadOption {
	return loadOption(func(c *LoadConfig) {
		c.ExcludeTypes = v
	})
}

// ExcludeNames sets the names to be excluded from the loaded package
// replacing the previous list. See [LoadConfig.ExcludeNames] for more details.
func ExcludeNames(names ...string) LoadOption {
	return loadOption(func(c *LoadConfig) {
		c.ExcludeNames = names
	})
}
